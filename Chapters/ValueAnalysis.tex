
\subsubsection{Value Analysis}
Strichman and Veitsmann \cite{DBLP:conf/fm/StrichmanV16} used \emph{value analysis} to improve the completeness of RVT. Value Analysis infers bounds on a program's variables' run-time values. This information might not be precise and is commonly an over approximation of the values. RVT uses Frama-C to analysis the values of the given programs. Frama-C is a platform for static analysis of C programs based on \emph{abstract interpretation} \cite{DBLP:conf/popl/CousotC77}. Abstract interpretation is a technique to gain information on semantic properties of a program by statically analyzing it. In our case the semantic property is the bound of the variables' values. It starts by noting for each variable its largest range (e.g. for 32-bit integers it would be [-2147483648,2147483647]). Then, whenever a statement modifying a variable is encountered, its range is refined with respect to intervals arithmetic. In the end we will have a range of possible values for each variable in the program. One may choose the abstraction level for the property to be analyzed. Following the former example, one may choose to analyze only the sign of the variables (i.e. $\{-,+,0\}$) because it might be enough for his purpose, such as knowing the sign of a multiplication product. The focus in \cite{DBLP:conf/fm/StrichmanV16} was on Frama-C value analysis plugin and was extended to support recursive functions. The problem was that some functions may be equivalent only under certain circumstances. RVT could not prove equivalence in such cases because it checked the equivalence of functions in a free context. This problem is even bigger due to the replacement of functions calls with UFs calls and thus more information is lost. The solution was to use the value analysis plugin output and assume it before calling UFs. Now, the SMT-Solver has knowledge on the range of the possible values this UF can produce, and the over approximation of its output is refined. In Figure \ref{fig:maorExample} we can see a pair of functions that demonstrates the above. $f1$ and $f2$ are not equivalent in the general case, but under the context of their main function they behave the same and therefore the programs are equivalent.
 
\begin{figure}[h]
\begin{center}
\begin{minipage}{7 cm}


\begin{lstlisting}
int f1(int n){
	if(n<=0) return -1;
	if(f1(n-1)<0) return 2;
	else return 5; 
}
int main(int x){ 
	if(x>1){
		return f1(x); 
	} 
}
\end{lstlisting}
\end{minipage}
\begin{minipage}{7 cm}
\begin{lstlisting}
int f2(int n){
	if(n<=0) return -1;
	if(f2(n-1)<0) return 4;
	else return 5; 
}
int main(int x){ 
	if(x>1){
		return f2(x); 
	} 
}
\end{lstlisting}
    


\end{minipage}
\caption{ Functions f1 and f2 are not semantically equivalent in a free context, but they are indeed equivalent under the context of their calling function main.}
\label{fig:maorExample}
\end{center}
\end{figure}
 
The second contribution of my research is using value analysis to assume bounds of input variables at the beginning of each function. RVT does not call CBMC with the original code, but rather composes a specific program for the pair it wants to check. In its first step it executes the functions to be checked with non-deterministic input. To make it possible, RVT slightly changes all the names on both sides so the programs can be merged without names collision. The outputs are saved into variables. In the end, RVT asserts that those variables are equal. CBMC translates this program to an SSA formula and tries to solve it. If it manages to do so it means it has found a proof for their equivalence. Otherwise it will generate a counter example on which the functions yield different results. \cite{DBLP:conf/fm/StrichmanV16} have shown how using value analysis could help the SMT solver used by CBMC to limit the values it tries to guess for the output of the UFs. We want to take this idea one step further. We would like every SSA formula CBMC creates to include a limit on the input variables. It is expected to prune the search space that the SMT solver explores. Using value analysis, we will add an assumption on the input variables bounds at the beginning of each function. An interesting benefit is the ability to compute bounds of variables that are read inside loops. As one recalls, RVT transforms every loop to a recursive function as a preliminary step before executing \alg{Prove}. Those generated functions receive as input all the variables that are read inside their respective loop \cite{DBLP:conf/vstte/StrichmanG05}. Therefore, when injecting the assumptions about the variables bounds, all the loops – that are now recursive functions – will be assigned limits to their read variables. Those include the variables inside the loop condition, and we expect it to help RVT strengthen its ability to prove equivalence. 

\begin{figure}[h]
\begin{center}
\begin{minipage}{8 cm}


\begin{lstlisting}
void increase1(int *a, int sz){
    int i, j;
    for (i=sz-1 ; i>0 ; i--) {
        for (j=0 ; j<i ; j++) {
	    assume(j < 4 && j >= 0);
            *(a+j) = *(a+j) +1;
        }
    }
}

int main() {
    int a[5];
    initialize_array(a);
    increase1(a,5);
    return 0;
}

\end{lstlisting}
\end{minipage}
\begin{minipage}{8 cm}
\begin{lstlisting}
void increase2(int *a, int sz){
    int i, j;
    for (i=sz-1 ; i>0 ; i--) {
        for (j=0 ; j<i ; j++) {
	    assume(j < 4 && j >= 0);
            a[j]++;
        }
    }
}

int main() {
    int a[5];
    initialize_array(a);
    increase2(a,5);
    return 0;
}
\end{lstlisting}
    


\end{minipage}
\caption{ Functions increase1 and increase2 cannot be proven equivalent by RVT without assuming the bounds of j.}
\label{fig:vaExample}
\end{center}
\end{figure}

\begin{example}
Consider the functions increase1 and increase2 in Figure \ref{fig:vaExample}. For the sake of this example, $initialize\_array$ is equal in both programs and initializes the arrays with the exact same values. If the assume statements were to be removed, RVT could not have proven the equivalence of increase1 and increase2. On the contrary, assuming the bounds of $j$ is enough for RVT to prove the equivalence. As explained in section \ref{sec:rvtreview}, in our preliminary steps we transform loops into recursions. let us call the functions that represent the inner loops as increase1\_for\_for and increase2\_for\_for respectively. One of the input variables for those functions is $j$, as it is read in the loop condition. Using value analysis we can assume at the beginning of increase1\_for\_for and increase2\_for\_for the maximum and minimum values of $j$ and by doing so helping RVT proving equivalence.
\end{example}
