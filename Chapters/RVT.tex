\label{sec:rvtreview}
\section{RVT's Strategy for Proving Equivalence}
RVT is a Regression Verification Tool developed by Godlin and Strichman \cite{DBLP:conf/dac/GodlinS09}. RVT tries to prove partial equivalence for a pair of programs. Its strategy to solve the program equivalence challenge is inspired by the Hoare's rule for recursive invocation \cite{DBLP:series/lnm/Hoare71}: 
\begin{equation}
 {\frac {\{p\} call\ \emph{proc} \{q\} \vdash_H \{p\} \emph{proc}-body \{q\}}{\{p\} call\ \emph{proc} \{q\}}} 
  (PART-EQ)
 \end{equation}
The rule says that if we can assume that {p} holds before the call to the procedure \emph{proc} and {q} holds afterward, and using this assumption we can prove that if {p} holds before executing the procedure body \emph{proc-body} then {q} holds afterward, so we can infer that if {p} holds before calling to \emph{proc} then it is granted that {q} will hold after the call. The revolutionary concept here is using what we want to infer as a hypothesis for the proof. They have created a new inference rule \cite{DBLP:conf/dac/GodlinS09}, in the spirit of the one we saw above. For $P1$ and $P2$ which are recursive procedures they say:
\begin{equation}
 {\frac {{\emph{in}[call\ P_1]=\emph{in}[call\ P_2]\rightarrow \emph{out}[call\ P_1]=\emph{out}[call\ P_2]} \vdash{\emph{in}[P_1\ body]=\emph{in}[P_2\ body]\rightarrow \emph{out}[P_1\ body]=\emph{out}[P_2\ body]} }
{{\emph{in}[call\ P_1]=\emph{in}[call\ P_2]\rightarrow \emph{out}[call\ P_1]=\emph{out}[call\ P_2]}}} 
\end{equation}
Basically, if the assumption that $P1$ and $P2$ produce the same output for the same input helps us to prove that the same input yields the same output upon executing $P1$ and $P2$ bodies then the congruence relation – equal input results in equal output – between $P1$ and $P2$ is proved. It was implemented by replacing recursive calls with calls to uninterrupted functions – $UF$s . An $UF$, as we explained earlier, is an over approximation of the substituted function that returns a non-deterministic value. By replacing the recursive call in both $P1$ and $P2$ with $UF$s that are defined as equal we have fulfilled the first part of the hypothesis. Then, all is left to do is prove the second part in order to prove the equivalence of $P1$ and $P2$. To Prove this equivalence, RVT generates a program calling both programs with the same non-deterministic input and asserts their output is equal as can be seen in figure \ref{fig:rvtmainprogram}.
\begin{figure}[h]
\begin{center}
\begin{minipage}{7 cm}

\begin{lstlisting}
i = non_det()
res1 = P1(i)
res2 = P2(i)
assert(res1 == res2) 
\end{lstlisting}
\end{minipage}
\caption{RVT's Generated Verification Program}
\label{fig:rvtmainprogram}
\end{center}
\end{figure}
CBMC is used to prove this assertion or produce a counter example in case of failure. CBMC is a bounded model checker. Given a C program (optionally including a user specification), it tries to verify for various things such as memory safety, general exceptions, undefined behavior, user assertions and more. It does so by unwinding loops and recursions and creating a \emph{Static Single Assignment} SMT formula which in turn is passed to an SMT Solver. The Solver will either prove the generated specification or produce a counter example that CBMC will provide to the user. 

\section{A Decomposition Algorithm For Program Equivalence}
All we have seen so far did not take any advantage of the similarity between the programs. RVT tries to excel in the case where the given programs are closely related. It aims for the complexity to be a function of the difference between the programs rather than their sizes. To do so we will show here RVT's decomposition algorithm in Algorithm \ref{alg:Prove}. \alg{Prove} receives a pair of programs $P$ and $P'$ and a (optionally partial) mapping between the functions in each program. RVT processes these programs before sending them to \alg{Prove}. All loops are transformed to recursive functions \cite{DBLP:conf/vstte/StrichmanG05}. That results in $P$ and $P'$ being loop-free. It is done because CBMC is bounded (i.e. K-bounded means it unrolls every loop and recursion K times), and it wants to prove equivalence agnostically to the number of iterations. Once those loops are recursions, RVT will try to prove their equivalence using $UF$ as we have shown above. RVT also creates $map_f$ before sending it to \alg{Prove}, starting with all the obvious mappings – identical functions and global variables with the same name. Then, recursively, it advances on the parse tree of both programs and tries to map more elements (such as variables, functions and types) in isomorphic locations. It is important to note that wrong mapping can't damage the soundness of \alg{Prove}, just its completeness. 
\alg{Prove} start by inlining nonrecursive nonmapped functions. Then it generates two graphs $MD_1$ and $MD_2$ where their nodes are the maximal strongly connected components (MSCC) in the call graphs of $P$ and $P'$. Because of the definition of MSCC, $MD_1$ and $MD_2$ are acyclic. After the setup in lines \ref{step:inline}-\ref{step:possible}, it starts traversing $MD_1$ and $MD_2$ bottom-up. Every MSCC is either trivial (i.e. a nonrecursive function) or nontrivial (i.e. one or more functions in a call cycle). When it encounters a pair of trivial MSCCs it checks for equivalence and marks its success if it managed to do so (line \ref{step:m1}-\ref{step:m1endIf}). If a pair of nontrivial MSCCs was encountered, a set S of functions pairs that their functions intersect all cycles in both MSCCs is chosen non deterministically. Equivalence is checked for each of those pairs. In case of failure on any of the pairs, RVT aborts. That is because once RVT can't prove equivalence for a recursive function (or mutually recursive functions) it cannot proceed proving any of its ancestors. This differs from the trivial MSCC case as functions in trivial MSCCs that were failed to be proved equal can be inlined in their ancestors when checking for their equivalence. In case of complete success (i.e. all the pairs in S were proved equivalent), RVT marks all the pairs in S as equivalent (lines \ref{step:select}-\ref{step:selectEnd}). Then the MSCC pair is marked as covered and RVT continues to the next mapped pair (line \ref{step:mark}).

\begin{algorithm}
\begin{algorithmic}[1]
\Function{Prove}{Programs $P,P'$, map between functions $map_f$}
\State \label{step:inline} Inline nonrecursive nonmapped functions;
\State \label{step:generate} Generate MSCC DAGs $MD_1, MD_2$
          from the call graphs of $P,P'$;
\State If possible,\label{step:possible} generate a bijective map $map_m$ between nontrivial nodes in $MD_1$ and $MD_2$ that is consistent with 
\mbox{~~~~~} $map_f$ (it is desirable but not necessary to add pairs of trivial nodes to $map_m$). Otherwise abort.
\While {$\exists \pair{m_1,m_2} \in map_m$
          that is uncovered and its children are "Covered"} \label{step:while}
  \State \label{step:choose} Choose such a pair $\pair{m_1,m_2}$;
  \If {$m_1,m_2$ are trivial} \label{step:m1}
    \State Let $f_1,f_2$ be the functions in $m_1,m_2$, respectively;
    \If {\alg{Check}($f_1,f_2$)} \label{step:Check}
          {mark $f_1,f_2$ as "Equivalent"; }
    \EndIf \label{step:m1endIf}
    \Else
      \State \label{step:select}Select nondeterministically a set of function pairs \newline \mbox{~~~~~~~~~~~~~~~~~} $S \subseteq \{\pair{f,f'}\mid \pair{f,f'} \in$ $map_f, f \in m_1, f' \in m_2\}$ that intersect all cycles in $m_1$ and $m_2$;
      \For {all $\pair{f,f'} \in S$}\label{step:forall}
        \If  {$\lnot\alg{oldCheck^r}(f,f',S)$} 
        \label{step:abort}{abort;} 
        \EndIf
      \EndFor
      \For {all $\pair{f,f'} \in S$} \label{step:forall2}
         mark $f,f'$ as "Equivalent";
      \EndFor
  \EndIf \label{step:selectEnd}
\State \label{step:mark} Mark $\pair{m_1,m_2}$ as "Covered".
\EndWhile
\EndFunction
\end{algorithmic}
\caption{A bottom-up decomposition algorithm for proving the partial equivalence of pairs of functions.}
\label{alg:Prove}
\end{algorithm}


\begin{algorithm}
\begin{algorithmic}[1]
\Function{Check}{function $f$, function $f'$}

\If {$f$ and $f'$ are syntactically equivalent and all their children
are marked "Equivalent"}

\State {\bf return} true;

\EndIf

\State {\bf return} CBMC ( $check-block (f,f')$);

\EndFunction
\end{algorithmic}
\caption{A function called by \alg{Prove} for checking the equivalence of two
input nonrecursive functions. check-block is a C program defined in the main text.}
\label{alg:Check}
\end{algorithm}

\begin{algorithm}
\begin{algorithmic}[1]
\Function {$oldCheck^r$}{function $f$, function $f'$, set of pairs $S$}

\If {$f$ and $f'$ are syntactically equivalent and all their children are
either marked "Equivalent" or in $S$}

\State {\bf return} true; \EndIf

\State {\bf return} CBMC ( $check-block^r$  $(f,f',S)$); \EndFunction
\end{algorithmic}
\caption{A function called by \alg{Prove} for checking the equivalence of two input functions that are part of MSCCs. $check-block^r$ is a C program defined in the main text.}
\label{alg:Checkr}
\end{algorithm}


The CBMC functions in \alg{Check} and $Check^r$ are the calls to CBMC as we explained before.
Although not presented in Algorithm \ref{alg:Prove}, it is important to understand the doom mechanic of RVT for the sections to come. As we can see in Algorithm \ref{alg:Prove}, once RVT fails to prove the equivalence of recursive functions, it aborts. In practice, when a recursive pair is discovered and cannot be proved as equivalent, RVT marks both functions of this pair as doomed and doom all their ancestors in both call graphs. When it traverses the graphs upward and encounters a doomed node, all the nodes in its MSCC are marked as doomed and the algorithm continues traversing toward the root. Another occasion where functions are marked as doomed is when a recursive function has no mapping. The reason behind this technique is that like the former case, if equivalence cannot be proven for a recursive function in the call graph, it is impossible for RVT to prove equivalence for any of its ancestors. Regular unmapped functions are not marked as doomed because they are inlined into their parents as part of the decomposition algorithm. One of the reasons it is implemented this way is that pairs which could not be proven equivalent only doom their own branches from being proven equivalent. Yet, other leaves of the call graphs could still be equivalent and there is no reason aborting the whole check. 
