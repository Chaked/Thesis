@inproceedings{DBLP:conf/dac/GodlinS09,
  author    = {Benny Godlin and
               Ofer Strichman},
  title     = {Regression verification},
  booktitle = {Proceedings of the 46th Design Automation Conference, {DAC} 2009,
               San Francisco, CA, USA, July 26-31, 2009},
  pages     = {466--471},
  year      = {2009},
  crossref  = {DBLP:conf/dac/2009},
  url       = {https://doi.org/10.1145/1629911.1630034},
  doi       = {10.1145/1629911.1630034},
  timestamp = {Tue, 06 Nov 2018 16:58:18 +0100},
  biburl    = {https://dblp.org/rec/bib/conf/dac/GodlinS09},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@article{DBLP:journals/jacm/Hoare03,
  author    = {C. A. R. Hoare},
  title     = {The verifying compiler: {A} grand challenge for computing research},
  journal   = {J. {ACM}},
  volume    = {50},
  number    = {1},
  pages     = {63--69},
  year      = {2003},
  url       = {https://doi.org/10.1145/602382.602403},
  doi       = {10.1145/602382.602403},
  timestamp = {Tue, 06 Nov 2018 12:51:46 +0100},
  biburl    = {https://dblp.org/rec/bib/journals/jacm/Hoare03},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@incollection{DBLP:series/lnm/Hoare71,
  author    = {C. A. R. Hoare},
  title     = {Procedures and parameters: An axiomatic approach},
  booktitle = {Symposium on Semantics of Algorithmic Languages},
  pages     = {102--116},
  year      = {1971},
  crossref  = {DBLP:series/lnm/1971-188},
  url       = {https://doi.org/10.1007/BFb0059696},
  doi       = {10.1007/BFb0059696},
  timestamp = {Tue, 16 May 2017 14:24:25 +0200},
  biburl    = {https://dblp.org/rec/bib/series/lnm/Hoare71},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/kbse/FelsingGKRU14,
  author    = {Dennis Felsing and
               Sarah Grebing and
               Vladimir Klebanov and
               Philipp R{\"{u}}mmer and
               Mattias Ulbrich},
  title     = {Automating regression verification},
  booktitle = {{ACM/IEEE} International Conference on Automated Software Engineering,
               {ASE} '14, Vasteras, Sweden - September 15 - 19, 2014},
  pages     = {349--360},
  year      = {2014},
  crossref  = {DBLP:conf/kbse/2014},
  url       = {https://doi.org/10.1145/2642937.2642987},
  doi       = {10.1145/2642937.2642987},
  timestamp = {Tue, 06 Nov 2018 16:58:23 +0100},
  biburl    = {https://dblp.org/rec/bib/conf/kbse/FelsingGKRU14},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@article{DBLP:journals/cacm/Dijkstra75,
  author    = {Edsger W. Dijkstra},
  title     = {Guarded Commands, Nondeterminacy and Formal Derivation of Programs},
  journal   = {Commun. {ACM}},
  volume    = {18},
  number    = {8},
  pages     = {453--457},
  year      = {1975},
  url       = {https://doi.org/10.1145/360933.360975},
  doi       = {10.1145/360933.360975},
  timestamp = {Wed, 14 Nov 2018 10:22:34 +0100},
  biburl    = {https://dblp.org/rec/bib/journals/cacm/Dijkstra75},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/sat/HoderB12,
  author    = {Krystof Hoder and
               Nikolaj Bj{\o}rner},
  title     = {Generalized Property Directed Reachability},
  booktitle = {Theory and Applications of Satisfiability Testing - {SAT} 2012 - 15th
               International Conference, Trento, Italy, June 17-20, 2012. Proceedings},
  pages     = {157--171},
  year      = {2012},
  crossref  = {DBLP:conf/sat/2012},
  url       = {https://doi.org/10.1007/978-3-642-31612-8\_13},
  doi       = {10.1007/978-3-642-31612-8\_13},
  timestamp = {Tue, 14 May 2019 10:00:41 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/sat/HoderB12},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/cav/RummerHK13,
  author    = {Philipp R{\"{u}}mmer and
               Hossein Hojjat and
               Viktor Kuncak},
  title     = {Disjunctive Interpolants for Horn-Clause Verification},
  booktitle = {Computer Aided Verification - 25th International Conference, {CAV}
               2013, Saint Petersburg, Russia, July 13-19, 2013. Proceedings},
  pages     = {347--363},
  year      = {2013},
  crossref  = {DBLP:conf/cav/2013},
  url       = {https://doi.org/10.1007/978-3-642-39799-8\_24},
  doi       = {10.1007/978-3-642-39799-8\_24},
  timestamp = {Tue, 14 May 2019 10:00:43 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/cav/RummerHK13},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/cav/LahiriHKR12,
  author    = {Shuvendu K. Lahiri and
               Chris Hawblitzel and
               Ming Kawaguchi and
               Henrique Reb{\^{e}}lo},
  title     = {{SYMDIFF:} {A} Language-Agnostic Semantic Diff Tool for Imperative
               Programs},
  booktitle = {Computer Aided Verification - 24th International Conference, {CAV}
               2012, Berkeley, CA, USA, July 7-13, 2012 Proceedings},
  pages     = {712--717},
  year      = {2012},
  crossref  = {DBLP:conf/cav/2012},
  url       = {https://doi.org/10.1007/978-3-642-31424-7\_54},
  doi       = {10.1007/978-3-642-31424-7\_54},
  timestamp = {Tue, 14 May 2019 10:00:43 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/cav/LahiriHKR12},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/cav/GurfinkelKKN15,
  author    = {Arie Gurfinkel and
               Temesghen Kahsai and
               Anvesh Komuravelli and
               Jorge A. Navas},
  title     = {The SeaHorn Verification Framework},
  booktitle = {Computer Aided Verification - 27th International Conference, {CAV}
               2015, San Francisco, CA, USA, July 18-24, 2015, Proceedings, Part
               {I}},
  pages     = {343--361},
  year      = {2015},
  crossref  = {DBLP:conf/cav/2015-1},
  url       = {https://doi.org/10.1007/978-3-319-21690-4\_20},
  doi       = {10.1007/978-3-319-21690-4\_20},
  timestamp = {Tue, 14 May 2019 10:00:43 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/cav/GurfinkelKKN15},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/tacas/GrebenshchikovGLPR12,
  author    = {Sergey Grebenshchikov and
               Ashutosh Gupta and
               Nuno P. Lopes and
               Corneliu Popeea and
               Andrey Rybalchenko},
  title     = {{HSF(C):} {A} Software Verifier Based on Horn Clauses - (Competition
               Contribution)},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems
               - 18th International Conference, {TACAS} 2012, Held as Part of the
               European Joint Conferences on Theory and Practice of Software, {ETAPS}
               2012, Tallinn, Estonia, March 24 - April 1, 2012. Proceedings},
  pages     = {549--551},
  year      = {2012},
  crossref  = {DBLP:conf/tacas/2012},
  url       = {https://doi.org/10.1007/978-3-642-28756-5\_46},
  doi       = {10.1007/978-3-642-28756-5\_46},
  timestamp = {Tue, 14 May 2019 10:00:53 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/tacas/GrebenshchikovGLPR12},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/cav/HeizmannHP13,
  author    = {Matthias Heizmann and
               Jochen Hoenicke and
               Andreas Podelski},
  title     = {Software Model Checking for People Who Love Automata},
  booktitle = {Computer Aided Verification - 25th International Conference, {CAV}
               2013, Saint Petersburg, Russia, July 13-19, 2013. Proceedings},
  pages     = {36--52},
  year      = {2013},
  crossref  = {DBLP:conf/cav/2013},
  url       = {https://doi.org/10.1007/978-3-642-39799-8\_2},
  doi       = {10.1007/978-3-642-39799-8\_2},
  timestamp = {Tue, 14 May 2019 10:00:43 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/cav/HeizmannHP13},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/vstte/StrichmanG05,
  author    = {Ofer Strichman and
               Benny Godlin},
  title     = {Regression Verification - {A} Practical Way to Verify Programs},
  booktitle = {Verified Software: Theories, Tools, Experiments, First {IFIP} {TC}
               2/WG 2.3 Conference, {VSTTE} 2005, Zurich, Switzerland, October 10-13,
               2005, Revised Selected Papers and Discussions},
  pages     = {496--501},
  year      = {2005},
  crossref  = {DBLP:conf/vstte/2005},
  url       = {https://doi.org/10.1007/978-3-540-69149-5\_54},
  doi       = {10.1007/978-3-540-69149-5\_54},
  timestamp = {Tue, 14 May 2019 10:00:49 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/vstte/StrichmanG05},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/fm/StrichmanV16,
  author    = {Ofer Strichman and
               Maor Veitsman},
  title     = {Regression Verification for Unbalanced Recursive Functions},
  booktitle = {{FM} 2016: Formal Methods - 21st International Symposium, Limassol,
               Cyprus, November 9-11, 2016, Proceedings},
  pages     = {645--658},
  year      = {2016},
  crossref  = {DBLP:conf/fm/2016},
  url       = {https://doi.org/10.1007/978-3-319-48989-6\_39},
  doi       = {10.1007/978-3-319-48989-6\_39},
  timestamp = {Tue, 14 May 2019 10:00:46 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/fm/StrichmanV16},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/popl/CousotC77,
  author    = {Patrick Cousot and
               Radhia Cousot},
  title     = {Abstract Interpretation: {A} Unified Lattice Model for Static Analysis
               of Programs by Construction or Approximation of Fixpoints},
  booktitle = {Conference Record of the Fourth {ACM} Symposium on Principles of Programming
               Languages, Los Angeles, California, USA, January 1977},
  pages     = {238--252},
  year      = {1977},
  crossref  = {DBLP:conf/popl/77},
  url       = {https://doi.org/10.1145/512950.512973},
  doi       = {10.1145/512950.512973},
  timestamp = {Tue, 06 Nov 2018 11:07:42 +0100},
  biburl    = {https://dblp.org/rec/bib/conf/popl/CousotC77},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{10.1007/978-3-540-78800-3_28,
author="Anand, Saswat
and Godefroid, Patrice
and Tillmann, Nikolai",
editor="Ramakrishnan, C. R.
and Rehof, Jakob",
title="Demand-Driven Compositional Symbolic Execution",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="367--381",
abstract="We discuss how to perform symbolic execution of large programs in a manner that is both compositional (hence more scalable) and demand-driven. Compositional symbolic execution means finding feasible interprocedural program paths by composing symbolic executions of feasible intraprocedural paths. By demand-driven, we mean that as few intraprocedural paths as possible are symbolically executed in order to form an interprocedural path leading to a specific target branch or statement of interest (like an assertion). A key originality of this work is that our demand-driven compositional interprocedural symbolic execution is performed entirely using first-order logic formulas solved with an off-the-shelf SMT (Satisfiability-Modulo-Theories) solver -- no procedure in-lining or custom algorithm is required for the interprocedural part. This allows a uniform and elegant way of summarizing procedures at various levels of detail and of composing those using logic formulas.",
isbn="978-3-540-78800-3"
}

@article{10.1145/360933.360975,
author = {Dijkstra, Edsger W.},
title = {Guarded Commands, Nondeterminacy and Formal Derivation of Programs},
year = {1975},
issue_date = {Aug. 1975},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {18},
number = {8},
issn = {0001-0782},
url = {https://doi.org/10.1145/360933.360975},
doi = {10.1145/360933.360975},
abstract = {So-called “guarded commands” are introduced as a building block for alternative and
repetitive constructs that allow nondeterministic program components for which at
least the activity evoked, but possibly even the final state, is not necessarily uniquely
determined by the initial state. For the formal derivation of programs expressed in
terms of these constructs, a calculus will be be shown.},
journal = {Commun. ACM},
month = aug,
pages = {453–457},
numpages = {5},
keywords = {programming language semantics, repetition, case-construction, program semantics, nondeterminancy, programming methodology, sequencing primitives, termination, derivation of programs, programming languages, correctness proof}
}

@techreport{kawaguchi2010conditional,
author = {Kawaguchi, Ming and Lahiri, Shuvendu and Rebelo, Henrique},
title = {Conditional equivalence},
year = {2010},
month = {October},
abstract = {A typical software module evolves through many versions over the course of its development. To maintain compatibility with module clients, it is crucial that a module's behavior at its interface does not change in an undesirable manner across versions. The problem of introducing changes which break interface behavior remains one of the most daunting challenges in the maintenance of large software modules.
Static equivalence checking of sequential programs is a useful mechanism to validate semantic equivalence across refactoring changes. However, most changes corresponding to bug fixes and feature additions change the behavior of programs; equivalence checking tools are of limited help in such cases.  In this work, we propose the notion of it  conditional (partial) equivalence, a more practical notion of equivalence in which two versions of a program need only be semantically equivalent under a subset of all inputs. We provide a compositional method for checking conditional equivalence and a fix-point procedure parameterized by an abstract domain for synthesizing non-trivial conditions under which two programs are equivalent.  Additionally, we propose a method called it  differential inlining to lazily construct summaries of behavioral differences along differential paths interprocedurally, for recursion-free programs.  We discuss preliminary experience of  prototype implementation on a set of medium sized C benchmarks.},
publisher = {Microsoft Research},
url = {https://www.microsoft.com/en-us/research/publication/conditional-equivalence/},
number = {MSR-TR-2010-119},
}

@InProceedings{10.1007/11408901_21,
author="Williams, Nicky
and Marre, Bruno
and Mouy, Patricia
and Roger, Muriel",
editor="Dal Cin, Mario
and Ka{\^a}niche, Mohamed
and Pataricza, Andr{\'a}s",
title="PathCrawler: Automatic Generation of Path Tests by Combining Static and Dynamic Analysis",
booktitle="Dependable Computing - EDCC 5",
year="2005",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="281--292",
abstract="We present the PathCrawler prototype tool for the automatic generation of test-cases satisfying the rigorous all-paths criterion, with a user-defined limit on the number of loop iterations in the covered paths. The prototype treats C code and we illustrate the test-case generation process on a representative example of a C function containing data-structures of variable dimensions, loops with variable numbers of iterations and many infeasible paths. PathCrawler is based on a novel combination of code instrumentation and constraint solving which makes it both efficient and open to extension. It suffers neither from the approximations and complexity of static analysis, nor from the number of executions demanded by the use of heuristic algorithms in function minimisation and the possibility that they fail to find a solution. We believe that it demonstrates the feasibility of rigorous and systematic testing of sequential programs coded in imperative languages.",
isbn="978-3-540-32019-7"
}

@inproceedings{10.1145/1321631.1321746,
author = {Sen, Koushik},
title = {Concolic Testing},
year = {2007},
isbn = {9781595938824},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1321631.1321746},
doi = {10.1145/1321631.1321746},
abstract = {Concolic testing automates test input generation by combining the concrete and symbolic (concolic) execution of the code under test. Traditional test input generation techniques use either (1) concrete execution or (2) symbolic execution that builds constraints and is followed by a generation of concrete test inputs from these constraints. In contrast, concolic testing tightly couples both concrete and symbolic executions: they run simultaneously, and each gets feedback from the other.We have implemented concolic testing in tools for testing both C and Java programs. We have used the tools to find bugs in several real-world software systems including SGLIB, a popular C data structure library used in a commercial tool, a third-party implementation of the Needham-Schroeder protocol and the TMN protocol, the scheduler of Honeywell's DEOS real-time operating system, and the Sun Microsystems' JDK 1.4 collection framework. In this tutorial, we will describe concolic testing and some of its recent extensions},
booktitle = {Proceedings of the Twenty-Second IEEE/ACM International Conference on Automated Software Engineering},
pages = {571–572},
numpages = {2},
keywords = {testing C programs, unit testing, random testing, testing tools, concolic testing, data structure testing, symbolic execution, explicit path model-checking},
location = {Atlanta, Georgia, USA},
series = {ASE '07}
}


