@book{D02,
	author = {Dustin E. },
	title = {Effective Software Testing: 50 SpecificWays to Improve Your Testing},
	date = {2002},
	publisher = {Addison-Wesley Professional}
}

@inproceedings{DBLP:conf/esec/Zeller99,
	author    = {Andreas Zeller},
	editor    = {Oscar Nierstrasz and
	Michel Lemoine},
	title     = {Yesterday, My Program Worked. Today, It Does Not. Why?},
	booktitle = {Software Engineering - ESEC/FSE'99, 7th European Software Engineering
	Conference, Held Jointly with the 7th {ACM} {SIGSOFT} Symposium on
	the Foundations of Software Engineering, Toulouse, France, September
	1999, Proceedings},
	series    = {Lecture Notes in Computer Science},
	volume    = {1687},
	pages     = {253--267},
	publisher = {Springer},
	year      = {1999},
	url       = {https://doi.org/10.1007/3-540-48166-4\_16},
	doi       = {10.1007/3-540-48166-4\_16},
	timestamp = {Tue, 27 Jul 2021 17:16:40 +0200},
	biburl    = {https://dblp.org/rec/conf/esec/Zeller99.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org}
}


@INPROCEEDINGS{C02,
	author = {Sorin Craciunescu},
	title = {Proving the Equivalence of CLP Programs},
	booktitle = {ICLP},
	year = {2002},
	pages = {287-301}
}

@INPROCEEDINGS{MK02,
	author = {Panagiotis Manolios and Matt Kaufmann},
	title = {Adding a Total Order to ACL2},
	booktitle = {The Third International Workshop on the ACL2 Theorem Prover},
	year = {2002}
}

@ARTICLE{MV06,
	author = {Panagiotis Manolios and Daron Vroon},
	title = {Ordinal Arithmetic: Algorithms and Mechanization},
	journal = {Journal of Automated Reasoning},
	year = {2006},
	note = {to appear}
}

@article{DBLP:journals/stvr/GodlinS13,
	author    = {Benny Godlin and
	Ofer Strichman},
	title     = {Regression verification: proving the equivalence of similar programs},
	journal   = {Softw. Test. Verification Reliab.},
	volume    = {23},
	number    = {3},
	pages     = {241--258},
	year      = {2013},
	url       = {https://doi.org/10.1002/stvr.1472},
	doi       = {10.1002/stvr.1472},
	timestamp = {Wed, 01 Apr 2020 08:46:22 +0200},
	biburl    = {https://dblp.org/rec/journals/stvr/GodlinS13.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/dac/GodlinS09,
  author    = {Benny Godlin and
               Ofer Strichman},
  title     = {Regression verification},
  booktitle = {Proceedings of the 46th Design Automation Conference, {DAC} 2009,
               San Francisco, CA, USA, July 26-31, 2009},
  pages     = {466--471},
  year      = {2009},
  crossref  = {DBLP:conf/dac/2009},
  url       = {https://doi.org/10.1145/1629911.1630034},
  doi       = {10.1145/1629911.1630034},
  timestamp = {Tue, 06 Nov 2018 16:58:18 +0100},
  biburl    = {https://dblp.org/rec/bib/conf/dac/GodlinS09},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@INPROCEEDINGS{GS07,
	author = {Benny Godlin and Ofer Strichman},
	title = {Regression Verification - a practical way to verify programs },
	booktitle = {VSTTE: Verified Software: theories, tools, experiments},
	year = {2005},
	editor = {Bertrand Meyer and Jim Woodcock},
	volume = {4171},
	series = lncs,
	note = {conf in 2005, published in 2007}
}

@UNPUBLISHED{GS06,
	author = {Benny Godlin and Ofer Strichman},
	title = {An Inference Rule for the Equivalence of Procedures},
	note = {(Submitted to Acta-Informatica)},
	owner = {ofers},
	timestamp = {2008.10.06}
}

@ARTICLE{GS08,
	author = {Benny Godlin and Ofer Strichman},
	title = {Inference Rules for Proving the Equivalence of Recursive Procedures},
	journal = {Acta Informatica},
	year = {2008},
	volume = {45},
	pages = {403--439},
	number = {6}
}

@article{DBLP:journals/jacm/Hoare03,
  author    = {C. A. R. Hoare},
  title     = {The verifying compiler: {A} grand challenge for computing research},
  journal   = {J. {ACM}},
  volume    = {50},
  number    = {1},
  pages     = {63--69},
  year      = {2003},
  url       = {https://doi.org/10.1145/602382.602403},
  doi       = {10.1145/602382.602403},
  timestamp = {Tue, 06 Nov 2018 12:51:46 +0100},
  biburl    = {https://dblp.org/rec/bib/journals/jacm/Hoare03},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@incollection{DBLP:series/lnm/Hoare71,
  author    = {C. A. R. Hoare},
  title     = {Procedures and parameters: An axiomatic approach},
  booktitle = {Symposium on Semantics of Algorithmic Languages},
  pages     = {102--116},
  year      = {1971},
  crossref  = {DBLP:series/lnm/1971-188},
  url       = {https://doi.org/10.1007/BFb0059696},
  doi       = {10.1007/BFb0059696},
  timestamp = {Tue, 16 May 2017 14:24:25 +0200},
  biburl    = {https://dblp.org/rec/bib/series/lnm/Hoare71},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{ckl2004,
	AUTHOR    = { Clarke, Edmund
	and Kroening, Daniel
	and Lerda, Flavio },
	TITLE     = { A Tool for Checking {ANSI-C} Programs },
	BOOKTITLE = { Tools and Algorithms for the Construction and Analysis of Systems (TACAS 2004) },
	YEAR      = { 2004 },
	PUBLISHER = { Springer },
	PAGES     = { 168--176 },
	ISBN      = { 3-540-21299-X },
	SERIES    = { Lecture Notes in Computer Science },
	VOLUME    = { 2988 },
	EDITOR    = { Kurt Jensen and Andreas Podelski },
}
@inproceedings{DBLP:conf/kbse/FelsingGKRU14,
  author    = {Dennis Felsing and
               Sarah Grebing and
               Vladimir Klebanov and
               Philipp R{\"{u}}mmer and
               Mattias Ulbrich},
  title     = {Automating regression verification},
  booktitle = {{ACM/IEEE} International Conference on Automated Software Engineering,
               {ASE} '14, Vasteras, Sweden - September 15 - 19, 2014},
  pages     = {349--360},
  year      = {2014},
  crossref  = {DBLP:conf/kbse/2014},
  url       = {https://doi.org/10.1145/2642937.2642987},
  doi       = {10.1145/2642937.2642987},
  timestamp = {Tue, 06 Nov 2018 16:58:23 +0100},
  biburl    = {https://dblp.org/rec/bib/conf/kbse/FelsingGKRU14},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@article{DBLP:journals/cacm/Dijkstra75,
  author    = {Edsger W. Dijkstra},
  title     = {Guarded Commands, Nondeterminacy and Formal Derivation of Programs},
  journal   = {Commun. {ACM}},
  volume    = {18},
  number    = {8},
  pages     = {453--457},
  year      = {1975},
  url       = {https://doi.org/10.1145/360933.360975},
  doi       = {10.1145/360933.360975},
  timestamp = {Wed, 14 Nov 2018 10:22:34 +0100},
  biburl    = {https://dblp.org/rec/bib/journals/cacm/Dijkstra75},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/sat/HoderB12,
  author    = {Krystof Hoder and
               Nikolaj Bj{\o}rner},
  title     = {Generalized Property Directed Reachability},
  booktitle = {Theory and Applications of Satisfiability Testing - {SAT} 2012 - 15th
               International Conference, Trento, Italy, June 17-20, 2012. Proceedings},
  pages     = {157--171},
  year      = {2012},
  crossref  = {DBLP:conf/sat/2012},
  url       = {https://doi.org/10.1007/978-3-642-31612-8\_13},
  doi       = {10.1007/978-3-642-31612-8\_13},
  timestamp = {Tue, 14 May 2019 10:00:41 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/sat/HoderB12},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/cav/RummerHK13,
  author    = {Philipp R{\"{u}}mmer and
               Hossein Hojjat and
               Viktor Kuncak},
  title     = {Disjunctive Interpolants for Horn-Clause Verification},
  booktitle = {Computer Aided Verification - 25th International Conference, {CAV}
               2013, Saint Petersburg, Russia, July 13-19, 2013. Proceedings},
  pages     = {347--363},
  year      = {2013},
  crossref  = {DBLP:conf/cav/2013},
  url       = {https://doi.org/10.1007/978-3-642-39799-8\_24},
  doi       = {10.1007/978-3-642-39799-8\_24},
  timestamp = {Tue, 14 May 2019 10:00:43 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/cav/RummerHK13},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/cav/LahiriHKR12,
  author    = {Shuvendu K. Lahiri and
               Chris Hawblitzel and
               Ming Kawaguchi and
               Henrique Reb{\^{e}}lo},
  title     = {{SYMDIFF:} {A} Language-Agnostic Semantic Diff Tool for Imperative
               Programs},
  booktitle = {Computer Aided Verification - 24th International Conference, {CAV}
               2012, Berkeley, CA, USA, July 7-13, 2012 Proceedings},
  pages     = {712--717},
  year      = {2012},
  crossref  = {DBLP:conf/cav/2012},
  url       = {https://doi.org/10.1007/978-3-642-31424-7\_54},
  doi       = {10.1007/978-3-642-31424-7\_54},
  timestamp = {Tue, 14 May 2019 10:00:43 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/cav/LahiriHKR12},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/cav/GurfinkelKKN15,
  author    = {Arie Gurfinkel and
               Temesghen Kahsai and
               Anvesh Komuravelli and
               Jorge A. Navas},
  title     = {The SeaHorn Verification Framework},
  booktitle = {Computer Aided Verification - 27th International Conference, {CAV}
               2015, San Francisco, CA, USA, July 18-24, 2015, Proceedings, Part
               {I}},
  pages     = {343--361},
  year      = {2015},
  crossref  = {DBLP:conf/cav/2015-1},
  url       = {https://doi.org/10.1007/978-3-319-21690-4\_20},
  doi       = {10.1007/978-3-319-21690-4\_20},
  timestamp = {Tue, 14 May 2019 10:00:43 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/cav/GurfinkelKKN15},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/tacas/GrebenshchikovGLPR12,
  author    = {Sergey Grebenshchikov and
               Ashutosh Gupta and
               Nuno P. Lopes and
               Corneliu Popeea and
               Andrey Rybalchenko},
  title     = {{HSF(C):} {A} Software Verifier Based on Horn Clauses - (Competition
               Contribution)},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems
               - 18th International Conference, {TACAS} 2012, Held as Part of the
               European Joint Conferences on Theory and Practice of Software, {ETAPS}
               2012, Tallinn, Estonia, March 24 - April 1, 2012. Proceedings},
  pages     = {549--551},
  year      = {2012},
  crossref  = {DBLP:conf/tacas/2012},
  url       = {https://doi.org/10.1007/978-3-642-28756-5\_46},
  doi       = {10.1007/978-3-642-28756-5\_46},
  timestamp = {Tue, 14 May 2019 10:00:53 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/tacas/GrebenshchikovGLPR12},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/cav/HeizmannHP13,
  author    = {Matthias Heizmann and
               Jochen Hoenicke and
               Andreas Podelski},
  title     = {Software Model Checking for People Who Love Automata},
  booktitle = {Computer Aided Verification - 25th International Conference, {CAV}
               2013, Saint Petersburg, Russia, July 13-19, 2013. Proceedings},
  pages     = {36--52},
  year      = {2013},
  crossref  = {DBLP:conf/cav/2013},
  url       = {https://doi.org/10.1007/978-3-642-39799-8\_2},
  doi       = {10.1007/978-3-642-39799-8\_2},
  timestamp = {Tue, 14 May 2019 10:00:43 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/cav/HeizmannHP13},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/vstte/StrichmanG05,
  author    = {Ofer Strichman and
               Benny Godlin},
  title     = {Regression Verification - {A} Practical Way to Verify Programs},
  booktitle = {Verified Software: Theories, Tools, Experiments, First {IFIP} {TC}
               2/WG 2.3 Conference, {VSTTE} 2005, Zurich, Switzerland, October 10-13,
               2005, Revised Selected Papers and Discussions},
  pages     = {496--501},
  year      = {2005},
  crossref  = {DBLP:conf/vstte/2005},
  url       = {https://doi.org/10.1007/978-3-540-69149-5\_54},
  doi       = {10.1007/978-3-540-69149-5\_54},
  timestamp = {Tue, 14 May 2019 10:00:49 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/vstte/StrichmanG05},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/fm/StrichmanV16,
  author    = {Ofer Strichman and
               Maor Veitsman},
  title     = {Regression Verification for Unbalanced Recursive Functions},
  booktitle = {{FM} 2016: Formal Methods - 21st International Symposium, Limassol,
               Cyprus, November 9-11, 2016, Proceedings},
  pages     = {645--658},
  year      = {2016},
  crossref  = {DBLP:conf/fm/2016},
  url       = {https://doi.org/10.1007/978-3-319-48989-6\_39},
  doi       = {10.1007/978-3-319-48989-6\_39},
  timestamp = {Tue, 14 May 2019 10:00:46 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/fm/StrichmanV16},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/popl/CousotC77,
  author    = {Patrick Cousot and
               Radhia Cousot},
  title     = {Abstract Interpretation: {A} Unified Lattice Model for Static Analysis
               of Programs by Construction or Approximation of Fixpoints},
  booktitle = {Conference Record of the Fourth {ACM} Symposium on Principles of Programming
               Languages, Los Angeles, California, USA, January 1977},
  pages     = {238--252},
  year      = {1977},
  crossref  = {DBLP:conf/popl/77},
  url       = {https://doi.org/10.1145/512950.512973},
  doi       = {10.1145/512950.512973},
  timestamp = {Tue, 06 Nov 2018 11:07:42 +0100},
  biburl    = {https://dblp.org/rec/bib/conf/popl/CousotC77},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{10.1007/978-3-540-78800-3_28,
author="Anand, Saswat
and Godefroid, Patrice
and Tillmann, Nikolai",
editor="Ramakrishnan, C. R.
and Rehof, Jakob",
title="Demand-Driven Compositional Symbolic Execution",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="367--381",
abstract="We discuss how to perform symbolic execution of large programs in a manner that is both compositional (hence more scalable) and demand-driven. Compositional symbolic execution means finding feasible interprocedural program paths by composing symbolic executions of feasible intraprocedural paths. By demand-driven, we mean that as few intraprocedural paths as possible are symbolically executed in order to form an interprocedural path leading to a specific target branch or statement of interest (like an assertion). A key originality of this work is that our demand-driven compositional interprocedural symbolic execution is performed entirely using first-order logic formulas solved with an off-the-shelf SMT (Satisfiability-Modulo-Theories) solver -- no procedure in-lining or custom algorithm is required for the interprocedural part. This allows a uniform and elegant way of summarizing procedures at various levels of detail and of composing those using logic formulas.",
isbn="978-3-540-78800-3"
}

@article{10.1145/360933.360975,
author = {Dijkstra, Edsger W.},
title = {Guarded Commands, Nondeterminacy and Formal Derivation of Programs},
year = {1975},
issue_date = {Aug. 1975},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {18},
number = {8},
issn = {0001-0782},
url = {https://doi.org/10.1145/360933.360975},
doi = {10.1145/360933.360975},
abstract = {So-called “guarded commands” are introduced as a building block for alternative and
repetitive constructs that allow nondeterministic program components for which at
least the activity evoked, but possibly even the final state, is not necessarily uniquely
determined by the initial state. For the formal derivation of programs expressed in
terms of these constructs, a calculus will be be shown.},
journal = {Commun. ACM},
month = aug,
pages = {453–457},
numpages = {5},
keywords = {programming language semantics, repetition, case-construction, program semantics, nondeterminancy, programming methodology, sequencing primitives, termination, derivation of programs, programming languages, correctness proof}
}

@techreport{kawaguchi2010conditional,
author = {Kawaguchi, Ming and Lahiri, Shuvendu and Rebelo, Henrique},
title = {Conditional equivalence},
year = {2010},
month = {October},
abstract = {A typical software module evolves through many versions over the course of its development. To maintain compatibility with module clients, it is crucial that a module's behavior at its interface does not change in an undesirable manner across versions. The problem of introducing changes which break interface behavior remains one of the most daunting challenges in the maintenance of large software modules.
Static equivalence checking of sequential programs is a useful mechanism to validate semantic equivalence across refactoring changes. However, most changes corresponding to bug fixes and feature additions change the behavior of programs; equivalence checking tools are of limited help in such cases.  In this work, we propose the notion of it  conditional (partial) equivalence, a more practical notion of equivalence in which two versions of a program need only be semantically equivalent under a subset of all inputs. We provide a compositional method for checking conditional equivalence and a fix-point procedure parameterized by an abstract domain for synthesizing non-trivial conditions under which two programs are equivalent.  Additionally, we propose a method called it  differential inlining to lazily construct summaries of behavioral differences along differential paths interprocedurally, for recursion-free programs.  We discuss preliminary experience of  prototype implementation on a set of medium sized C benchmarks.},
publisher = {Microsoft Research},
url = {https://www.microsoft.com/en-us/research/publication/conditional-equivalence/},
number = {MSR-TR-2010-119},
}

@InProceedings{10.1007/11408901_21,
author="Williams, Nicky
and Marre, Bruno
and Mouy, Patricia
and Roger, Muriel",
editor="Dal Cin, Mario
and Ka{\^a}niche, Mohamed
and Pataricza, Andr{\'a}s",
title="PathCrawler: Automatic Generation of Path Tests by Combining Static and Dynamic Analysis",
booktitle="Dependable Computing - EDCC 5",
year="2005",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="281--292",
abstract="We present the PathCrawler prototype tool for the automatic generation of test-cases satisfying the rigorous all-paths criterion, with a user-defined limit on the number of loop iterations in the covered paths. The prototype treats C code and we illustrate the test-case generation process on a representative example of a C function containing data-structures of variable dimensions, loops with variable numbers of iterations and many infeasible paths. PathCrawler is based on a novel combination of code instrumentation and constraint solving which makes it both efficient and open to extension. It suffers neither from the approximations and complexity of static analysis, nor from the number of executions demanded by the use of heuristic algorithms in function minimisation and the possibility that they fail to find a solution. We believe that it demonstrates the feasibility of rigorous and systematic testing of sequential programs coded in imperative languages.",
isbn="978-3-540-32019-7"
}

@inproceedings{10.1145/1321631.1321746,
author = {Sen, Koushik},
title = {Concolic Testing},
year = {2007},
isbn = {9781595938824},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1321631.1321746},
doi = {10.1145/1321631.1321746},
abstract = {Concolic testing automates test input generation by combining the concrete and symbolic (concolic) execution of the code under test. Traditional test input generation techniques use either (1) concrete execution or (2) symbolic execution that builds constraints and is followed by a generation of concrete test inputs from these constraints. In contrast, concolic testing tightly couples both concrete and symbolic executions: they run simultaneously, and each gets feedback from the other.We have implemented concolic testing in tools for testing both C and Java programs. We have used the tools to find bugs in several real-world software systems including SGLIB, a popular C data structure library used in a commercial tool, a third-party implementation of the Needham-Schroeder protocol and the TMN protocol, the scheduler of Honeywell's DEOS real-time operating system, and the Sun Microsystems' JDK 1.4 collection framework. In this tutorial, we will describe concolic testing and some of its recent extensions},
booktitle = {Proceedings of the Twenty-Second IEEE/ACM International Conference on Automated Software Engineering},
pages = {571–572},
numpages = {2},
keywords = {testing C programs, unit testing, random testing, testing tools, concolic testing, data structure testing, symbolic execution, explicit path model-checking},
location = {Atlanta, Georgia, USA},
series = {ASE '07}
}

@INPROCEEDINGS{9285657,  author={Feng, Nick and Mora, Federico and Hui, Vincent and Chechik, Marsha},  booktitle={2020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)},   title={Scaling Client-Specific Equivalence Checking via Impact Boundary Search},   year={2020},  volume={},  number={},  pages={734-745},  doi={}}

@inbook{10.1145/3238147.3238178,
author = {Mora, Federico and Li, Yi and Rubin, Julia and Chechik, Marsha},
title = {Client-Specific Equivalence Checking},
year = {2018},
isbn = {9781450359375},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3238147.3238178},
abstract = {Software is often built by integrating components created by different teams or even different organizations. With little understanding of changes in dependent components, it is challenging to maintain correctness and robustness of the entire system. In this paper, we investigate the effect of component changes on the behavior of their clients. We observe that changes in a component are often irrelevant to a particular client and thus can be adopted without any delays or negative effects. Following this observation, we formulate the notion of client-specific equivalence checking (CSE) and develop an automated technique optimized for checking such equivalence. We evaluate our technique on a set of benchmarks, including those from the existing literature on equivalence checking, and show its applicability and effectiveness.},
booktitle = {Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering},
pages = {441–451},
numpages = {11}
}

@inproceedings{10.1145/3368089.3409757,
author = {Badihi, Sahar and Akinotcho, Faridah and Li, Yi and Rubin, Julia},
title = {ARDiff: Scaling Program Equivalence Checking via Iterative Abstraction and Refinement of Common Code},
year = {2020},
isbn = {9781450370431},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3368089.3409757},
doi = {10.1145/3368089.3409757},
abstract = {},
booktitle = {Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
pages = {13–24},
numpages = {12},
keywords = {Equivalence checking, program analysis, software evolution, symbolic execution},
location = {Virtual Event, USA},
series = {ESEC/FSE 2020}
}

@inproceedings{FelsingGrebingKlebanov2014,
	author = {Dennis Felsing and Sarah Grebing and Vladimir Klebanov and
                  Philipp R\"{u}mmer and Mattias Ulbrich},
	title = {Automating Regression Verification},
	booktitle = {29th IEEE/ACM International Conference on Automated Software Engineering (ASE 2014)},
	series = {ASE '14},
	month = sep,
	year = {2014},
	pages = {349--360},
        numpages = {12},
        doi = {10.1145/2642937.2642987},
        acmid = {2642987},
        publisher = {ACM},
        keywords = {formal methods, invariant generation, program equivalence, regression verification, IMPROVE}
}

@InProceedings{10.1007/978-3-030-99527-0_20,
author="Beyer, Dirk",
editor="Fisman, Dana
and Rosu, Grigore",
title="Progress on Software Verification: SV-COMP 2022",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2022",
publisher="Springer International Publishing",
address="Cham",
pages="375--402",
abstract="The 11th edition of the Competition on Software Verification (SV-COMP 2022) provides the largest ever overview of tools for software verification. The competition is an annual comparative evaluation of fully automatic software verifiers for C and Java programs. The objective is to provide an overview of the state of the art in terms of effectiveness and efficiency of software verification, establish standards, provide a platform for exchange to developers of such tools, educate PhD students on reproducibility approaches and benchmarking, and provide computing resources to developers that do not have access to compute clusters. The competition consisted of 15 648 verification tasks for C programs and 586 verification tasks for Java programs. Each verification task consisted of a program and a property (reachability, memory safety, overflows, termination). The new category on data-race detection was introduced as demonstration category. SV-COMP 2022 had 47 participating verification systems from 33 teams from 11 countries.",
isbn="978-3-030-99527-0"
}


@InProceedings{10.1007/978-3-642-22110-1_16,
author="Beyer, Dirk
and Keremoglu, M. Erkan",
editor="Gopalakrishnan, Ganesh
and Qadeer, Shaz",
title="CPAchecker: A Tool for Configurable Software Verification",
booktitle="Computer Aided Verification",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="184--190",
abstract="Configurable software verification is a recent concept for expressing different program analysis and model checking approaches in one single formalism. This paper presents CPAchecker, a tool and framework that aims at easy integration of new verification components. Every abstract domain, together with the corresponding operations, implements the interface of configurable program analysis (CPA). The main algorithm is configurable to perform a reachability analysis on arbitrary combinations of existing CPAs. In software verification, it takes a considerable amount of effort to convert a verification idea into actual experimental results --- we aim at accelerating this process. We hope that researchers find it convenient and productive to implement new verification ideas and algorithms using this flexible and easy-to-extend platform, and that it advances the field by making it easier to perform practical experiments. The tool is implemented in Java and runs as command-line tool or as eclipse plug-in. CPAchecker implements CPAs for several abstract domains. We evaluate the efficiency of the current version of our tool on software-verification benchmarks from the literature, and compare it with other state-of-the-art model checkers. CPAchecker is an open-source toolkit and publicly available.",
isbn="978-3-642-22110-1"
}

@InProceedings{10.1007/978-3-319-89963-3_30,
author="Heizmann, Matthias
and Chen, Yu-Fang
and Dietsch, Daniel
and Greitschus, Marius
and Hoenicke, Jochen
and Li, Yong
and Nutz, Alexander
and Musa, Betim
and Schilling, Christian
and Schindler, Tanja
and Podelski, Andreas",
editor="Beyer, Dirk
and Huisman, Marieke",
title="Ultimate Automizer and the Search for Perfect Interpolants",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="447--451",
isbn="978-3-319-89963-3"
}

@inbook{inbook,
author = {Chalupa, Marek and Mihalkovič, Vincent and Řechtáčková, Anna and Zaoral, Lukáš and Strejček, Jan},
year = {2022},
month = {01},
pages = {462-467},
title = {Symbiotic 9: String Analysis and Backward Symbolic Execution with Loop Folding: (Competition Contribution)},
isbn = {978-3-030-99526-3},
doi = {10.1007/978-3-030-99527-0_32}
}

@inproceedings{inproceedings,
author = {Backes, John and Person, Suzette and Rungta, Neha and Tkachuk, Oksana},
year = {2013},
month = {07},
pages = {},
title = {Regression Verification Using Impact Summaries},
volume = {7976},
isbn = {978-3-642-39175-0},
doi = {10.1007/978-3-642-39176-7_7}
}

@inproceedings{10.1145/1453101.1453131,
author = {Person, Suzette and Dwyer, Matthew B. and Elbaum, Sebastian and Pundefinedsundefinedreanu, Corina S.},
title = {Differential Symbolic Execution},
year = {2008},
isbn = {9781595939951},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1453101.1453131},
doi = {10.1145/1453101.1453131},
pages = {226–237},
numpages = {12},
keywords = {program differencing, symbolic execution, software evolution},
location = {Atlanta, Georgia},
series = {SIGSOFT '08/FSE-16}
}

@InProceedings{10.1007/978-3-319-66706-5_20,
author="Trostanetski, Anna
and Grumberg, Orna
and Kroening, Daniel",
editor="Ranzato, Francesco",
title="Modular Demand-Driven Analysis of Semantic Difference for Program Versions",
booktitle="Static Analysis",
year="2017",
publisher="Springer International Publishing",
address="Cham",
pages="405--427",
isbn="978-3-319-66706-5"
}

@InProceedings{10.1007/10722167_15,
author="Clarke, Edmund
and Grumberg, Orna
and Jha, Somesh
and Lu, Yuan
and Veith, Helmut",
editor="Emerson, E. Allen
and Sistla, Aravinda Prasad",
title="Counterexample-Guided Abstraction Refinement ",
booktitle="Computer Aided Verification",
year="2000",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="154--169",
abstract="We present an automatic iterative abstraction-refinement methodology in which the initial abstract model is generated by an automatic analysis of the control structures in the program to be verified. Abstract models may admit erroneous (or ``spurious'') counterexamples. We devise new symbolic techniques which analyze such counterexamples and refine the abstract model correspondingly. The refinement algorithm keeps the size of the abstract state space small due to the use of abstraction functions which distinguish many degrees of abstraction for each program variable. We describe an implementation of our methodology in NuSMV. Practical experiments including a large Fujitsu IP core design with about 500 latches and 10000 lines of SMV code confirm the effectiveness of our approach.",
isbn="978-3-540-45047-4"
}

